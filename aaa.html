<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>雙流體最終修復版：秒開 + RWD對齊</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        
        /* --- 1. SVG 光束容器 --- */
        .beam-container {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            z-index: 0; 
            pointer-events: none;
            opacity: 0.9;
            /* 底部柔和遮罩 */
            -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            visibility: hidden; /* 計算完成前隱藏 */
            filter: blur(2px);
        }

        .beam-svg {
            width: 100%; height: 100%; display: block; overflow: visible;
        }

        /* --- Canvas --- */
        canvas { position: absolute; top: 0; left: 0; z-index: 1; display: block; }

        /* --- UI --- */
        .ui-controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.85); padding: 20px;
            border-radius: 12px; font-family: 'Segoe UI', sans-serif;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 320px; color: #fff; border: 1px solid #333; z-index: 10;
        }
        .ui-controls h3 { margin: 0 0 15px 0; font-size: 18px; color: #00ffcc; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .param-group { margin-bottom: 10px; font-size: 13px; color: #ccc;}
        .val { font-weight: bold; color: #fff; float: right; }
    </style>
</head>
<body>

    <div id="beamContainer" class="beam-container">
        <svg id="mainSvg" class="beam-svg" preserveAspectRatio="none">
            <defs>
                <linearGradient id="mainGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#00ffcc; stop-opacity:0.2" />
                    <stop offset="50%" style="stop-color:#ffffff; stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#00ffcc; stop-opacity:0.8" />
                </linearGradient>
            </defs>
            
            <path id="beamPath" 
                  d="M1 0.0136719C2.16667 88.5137 6.5 302.014 28.5 352.014C56 414.514 138.5 413.514 181.5 416.514C224.5 419.514 292.5 414.514 309 440.514 L -309 440.514 C -292.5 414.514 -224.5 419.514 -181.5 416.514 C -138.5 413.514 -56 414.514 -28.5 352.014 C -6.5 302.014 -2.16667 88.5137 -1 0.0136719 Z" 
                  fill="url(#mainGradient)" 
            />
        </svg>
    </div>

    <div class="ui-controls">
        <h3>⚡ 效能修復版</h3>
        <div class="param-group">
            <span>運算耗時:</span> <span class="val" style="color:#0f0">極短 (已優化)</span>
        </div>
        <div class="param-group">
            <span>RWD 對齊:</span> <span class="val" style="color:#0f0">自動鎖定</span>
        </div>
    </div>

    <div style="display:none;">
        <svg id="profile-svg">
            <path id="profile-path" d="M1 0.0136719C2.16667 88.5137 6.5 302.014 28.5 352.014C56 414.514 138.5 413.514 181.5 416.514C224.5 419.514 292.5 414.514 309 440.514" />
        </svg>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ==========================================
        // 1. 環境參數
        // ==========================================
        const env = {
            spawnHeight: 350,   
            floorHeight: 0,     
            gravity: 4.0,
            
            // 下面的數值會由 initProfileData 自動計算
            svgMaxX: 0, 
            svgMaxY: 0
        };

        // 粒子設定 (白色已移除)
        const configRed = { type: 'points', count: 3000, color: 0xff0000, size: 3.5, opacity: 0.8, speedScale: 1.0, rotationSpeed: 0.05, radiusNoise: 6.0, centerX: 0 };
        const configBlack = { type: 'streaks', count: 1000, color: 0x000000, opacity: 0.8, streakLength: 15.0, speedScale: 1.5, rotationSpeed: 0.15, radiusNoise: 2.0, centerX: 0 };
        const configPurple = { type: 'points', count: 3000, color: 0x800080, size: 3.5, opacity: 0.8, speedScale: 1.0, rotationSpeed: 0.05, radiusNoise: 6.0, centerX: 0 };
        const configPink = { type: 'streaks', count: 1000, color: 0xFF69B4, opacity: 0.8, streakLength: 15.0, speedScale: 1.5, rotationSpeed: 0.15, radiusNoise: 2.0, centerX: 0 };
        
        // ==========================================
        // 2. 初始化場景
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = null; 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(0, 80, 500); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableRotate = false; // 鎖定視角
        controls.enableZoom = false; 
        controls.enablePan = false;

        // 地板網格
        const planeGeo = new THREE.PlaneGeometry(600, 600);
        const borderGeo = new THREE.EdgesGeometry(planeGeo);
        const borderMat = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
        const border = new THREE.LineSegments(borderGeo, borderMat);
        border.rotation.x = Math.PI / 2;
        border.position.y = env.floorHeight;
        scene.add(border);

        // ==========================================
        // 3. SVG 路徑解析 (★ 效能優化版 ★)
        // ==========================================
        const profilePathData = document.getElementById('profile-path').getAttribute('d');
        const profileLUT = [];
        const lutResolution = 1000;
        let maxSvgHeight = 0;

        function initProfileData() {
            const pathEl = document.getElementById('profile-path');
            const totalLen = pathEl.getTotalLength();
            const tempPoints = [];

            // 步驟 1: 只掃描一次 SVG (1000 個取樣點)
            // 這是最耗時的部分，現在只做一次
            for (let i = 0; i <= lutResolution; i++) {
                const point = pathEl.getPointAtLength(totalLen * (i / lutResolution));
                tempPoints.push({ x: point.x, y: point.y });
                
                // 自動偵測最大高度與寬度 (RWD 用)
                if (point.y > maxSvgHeight) maxSvgHeight = point.y;
                if (Math.abs(point.x) > env.svgMaxX) env.svgMaxX = Math.abs(point.x);
            }
            env.svgMaxY = maxSvgHeight;

            // 步驟 2: 建立查表 (在記憶體中快速比對)
            // 這裡不再呼叫 getPointAtLength，只做簡單的陣列搜尋
            for (let y = 0; y <= Math.ceil(maxSvgHeight); y++) {
                let matchX = 0;
                // 在 tempPoints 裡找最接近 y 的點 (簡單線性搜尋，非常快)
                // 由於 tempPoints 是排序的，可以用 reduce 高效完成
                const closest = tempPoints.reduce((prev, curr) => 
                    Math.abs(curr.y - y) < Math.abs(prev.y - y) ? curr : prev
                );
                profileLUT[y] = closest.x;
            }
            
            // 更新 SVG 的 viewBox 以匹配自動偵測的尺寸
            const mainSvg = document.getElementById('mainSvg');
            const w = env.svgMaxX * 2; // 左右對稱
            const h = env.svgMaxY;
            // 設定 viewBox: x從 -width/2 開始
            mainSvg.setAttribute('viewBox', `-${env.svgMaxX} 0 ${w} ${h}`);
        }
        initProfileData();

        function getRadiusFromProfile(progress) {
            const p = Math.max(0, Math.min(1, progress));
            const targetY = p * maxSvgHeight;
            return profileLUT[Math.floor(targetY)] || 0;
        }

        // ==========================================
        // 4. 粒子系統
        // ==========================================
        const tempVec = new THREE.Vector3();
        const tempVecTail = new THREE.Vector3();

        function calculatePosition(y, angle, noise, centerX, targetVec) {
            const totalHeight = env.spawnHeight - env.floorHeight;
            let activeY = y;
            if (activeY < env.floorHeight - 50) activeY = env.spawnHeight; 
            let progress = (env.spawnHeight - activeY) / totalHeight;
            let svgRadius = getRadiusFromProfile(Math.min(1, progress));
            if (progress > 1) svgRadius += (progress - 1) * 200; 
            let finalRadius = svgRadius + noise;
            targetVec.set(centerX + Math.cos(angle) * finalRadius, activeY, Math.sin(angle) * finalRadius);
        }

        function createDotSystem(config) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.count * 3);
            const initialData = [];
            for (let i = 0; i < config.count; i++) {
                const y = THREE.MathUtils.randFloat(env.floorHeight - 50, env.spawnHeight);
                positions[i * 3] = 0; positions[i * 3 + 1] = y; positions[i * 3 + 2] = 0;
                initialData.push({ y: y, speed: env.gravity * config.speedScale + Math.random(), angleStart: Math.random() * Math.PI * 2, radiusOffset: (Math.random() - 0.5) * config.radiusNoise });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: config.color, size: config.size, sizeAttenuation: true, transparent: true, opacity: config.opacity, depthWrite: false, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Points(geometry, material);
            mesh.userData = { config: config, initialData: initialData };
            return mesh;
        }

        function createStreakSystem(config) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.count * 2 * 3); 
            const initialData = [];
            for (let i = 0; i < config.count; i++) {
                const y = THREE.MathUtils.randFloat(env.floorHeight - 50, env.spawnHeight);
                initialData.push({ y: y, speed: env.gravity * config.speedScale + Math.random() * 2.0, angleStart: Math.random() * Math.PI * 2, radiusOffset: (Math.random() - 0.5) * config.radiusNoise });
                positions[i*6] = 0; positions[i*6+1] = 0; positions[i*6+2] = 0;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({ color: config.color, transparent: true, opacity: config.opacity, depthWrite: false, blending: THREE.AdditiveBlending });
            const mesh = new THREE.LineSegments(geometry, material);
            mesh.userData = { config: config, initialData: initialData };
            return mesh;
        }

        function updateSystem(mesh, time) {
            const positions = mesh.geometry.attributes.position.array;
            const data = mesh.userData.initialData;
            const cfg = mesh.userData.config;
            const isStreak = cfg.type === 'streaks';
            for (let i = 0; i < cfg.count; i++) {
                const p = data[i];
                p.y -= p.speed;
                if (p.y < env.floorHeight - 50) p.y = env.spawnHeight;
                const angle = p.angleStart + (time * cfg.rotationSpeed);
                if (!isStreak) {
                    const i3 = i * 3;
                    calculatePosition(p.y, angle, p.radiusOffset, cfg.centerX, tempVec);
                    positions[i3] = tempVec.x; positions[i3 + 1] = tempVec.y; positions[i3 + 2] = tempVec.z;
                } else {
                    const headIdx = i * 6; const tailIdx = i * 6 + 3;
                    calculatePosition(p.y, angle, p.radiusOffset, cfg.centerX, tempVec);
                    const tailY = p.y + cfg.streakLength; const tailAngle = angle - 0.01; 
                    calculatePosition(tailY, tailAngle, p.radiusOffset, cfg.centerX, tempVecTail);
                    positions[headIdx] = tempVec.x; positions[headIdx + 1] = tempVec.y; positions[headIdx + 2] = tempVec.z;
                    positions[tailIdx] = tempVecTail.x; positions[tailIdx + 1] = tempVecTail.y; positions[tailIdx + 2] = tempVecTail.z;
                }
            }
            mesh.geometry.attributes.position.needsUpdate = true;
        }

        // ==========================================
        // 5. RWD 對齊系統 (3D -> 2D 投影)
        // ==========================================
        const svgContainer = document.getElementById('beamContainer');
        const vecTop = new THREE.Vector3();
        const vecBottom = new THREE.Vector3();
        const vecWidth = new THREE.Vector3();

        function updateBeam2DPosition() {
            // 自動使用計算出的最大寬度，確保對齊
            vecTop.set(0, env.spawnHeight, 0);
            vecBottom.set(0, env.floorHeight, 0);
            vecWidth.set(env.svgMaxX, env.floorHeight, 0);

            vecTop.project(camera);
            vecBottom.project(camera);
            vecWidth.project(camera);

            const w = window.innerWidth;
            const h = window.innerHeight;
            
            const yTop = (-(vecTop.y * 0.5) + 0.5) * h;
            const yBottom = (-(vecBottom.y * 0.5) + 0.5) * h;
            const beamPixelHeight = yBottom - yTop;

            const xCenter = (vecBottom.x * 0.5 + 0.5) * w;
            const xRight = (vecWidth.x * 0.5 + 0.5) * w;
            const beamPixelWidth = (xRight - xCenter) * 2; 

            svgContainer.style.top = yTop + 'px';
            svgContainer.style.height = beamPixelHeight + 'px';
            svgContainer.style.width = beamPixelWidth + 'px';
            svgContainer.style.visibility = 'visible';
        }

        // ==========================================
        // 6. 執行
        // ==========================================
        const sysRed = createDotSystem(configRed);
        const sysBlack = createStreakSystem(configBlack);
        const sysPurple = createDotSystem(configPurple);
        const sysPink = createStreakSystem(configPink);
        
        scene.add(sysRed);
        scene.add(sysBlack);
        scene.add(sysPurple);
        scene.add(sysPink);

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 1;
            
            updateSystem(sysRed, time);
            updateSystem(sysBlack, time);
            updateSystem(sysPurple, time);
            updateSystem(sysPink, time);
            
            updateBeam2DPosition(); // 每幀對齊
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>